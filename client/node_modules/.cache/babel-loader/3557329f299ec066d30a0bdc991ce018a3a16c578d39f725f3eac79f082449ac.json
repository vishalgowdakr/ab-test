{"ast":null,"code":"import { checkBroadcastingRules } from '../../../utils/array.js';\nimport { factory } from '../../../utils/factory.js';\nvar name = 'broadcast';\nvar dependancies = ['concat'];\nexport var createBroadcast = /* #__PURE__ */factory(name, dependancies, _ref => {\n  var {\n    concat\n  } = _ref;\n  /**\n  * Broadcasts two matrices, and return both in an array\n  * It checks if it's possible with broadcasting rules\n  *\n  * @param {Matrix}   A      First Matrix\n  * @param {Matrix}   B      Second Matrix\n  *\n  * @return {Matrix[]}      [ broadcastedA, broadcastedB ]\n  */\n  return function (A, B) {\n    var N = Math.max(A._size.length, B._size.length); // max number of dims\n    if (A._size.length === B._size.length) {\n      if (A._size.every((dim, i) => dim === B._size[i])) {\n        // If matrices have the same size return them\n        return [A, B];\n      }\n    }\n    var sizeA = _padLeft(A._size, N, 0); // pad to the left to align dimensions to the right\n    var sizeB = _padLeft(B._size, N, 0); // pad to the left to align dimensions to the right\n\n    // calculate the max dimensions\n    var sizeMax = [];\n    for (var dim = 0; dim < N; dim++) {\n      sizeMax[dim] = Math.max(sizeA[dim], sizeB[dim]);\n    }\n\n    // check if the broadcasting rules applyes for both matrices\n    checkBroadcastingRules(sizeA, sizeMax);\n    checkBroadcastingRules(sizeB, sizeMax);\n\n    // reshape A or B if needed to make them ready for concat\n    var AA = A.clone();\n    var BB = B.clone();\n    if (AA._size.length < N) {\n      AA.reshape(_padLeft(AA._size, N, 1));\n    } else if (BB._size.length < N) {\n      BB.reshape(_padLeft(BB._size, N, 1));\n    }\n\n    // stretches the matrices on each dimension to make them the same size\n    for (var _dim = 0; _dim < N; _dim++) {\n      if (AA._size[_dim] < sizeMax[_dim]) {\n        AA = _stretch(AA, sizeMax[_dim], _dim);\n      }\n      if (BB._size[_dim] < sizeMax[_dim]) {\n        BB = _stretch(BB, sizeMax[_dim], _dim);\n      }\n    }\n\n    // return the array with the two broadcasted matrices\n    return [AA, BB];\n  };\n  function _padLeft(shape, N, filler) {\n    // pads an array of dimensions with numbers to the left, unitl the number of dimensions is N\n    return [...Array(N - shape.length).fill(filler), ...shape];\n  }\n  function _stretch(arrayToStretch, sizeToStretch, dimToStretch) {\n    // stretches a matrix up to a certain size in a certain dimension\n    return concat(...Array(sizeToStretch).fill(arrayToStretch), dimToStretch);\n  }\n});","map":{"version":3,"names":["checkBroadcastingRules","factory","name","dependancies","createBroadcast","_ref","concat","A","B","N","Math","max","_size","length","every","dim","i","sizeA","_padLeft","sizeB","sizeMax","AA","clone","BB","reshape","_dim","_stretch","shape","filler","Array","fill","arrayToStretch","sizeToStretch","dimToStretch"],"sources":["/home/vishal/Documents/htmx/abtest/node_modules/mathjs/lib/esm/type/matrix/utils/broadcast.js"],"sourcesContent":["import { checkBroadcastingRules } from '../../../utils/array.js';\nimport { factory } from '../../../utils/factory.js';\nvar name = 'broadcast';\nvar dependancies = ['concat'];\nexport var createBroadcast = /* #__PURE__ */factory(name, dependancies, _ref => {\n  var {\n    concat\n  } = _ref;\n  /**\n  * Broadcasts two matrices, and return both in an array\n  * It checks if it's possible with broadcasting rules\n  *\n  * @param {Matrix}   A      First Matrix\n  * @param {Matrix}   B      Second Matrix\n  *\n  * @return {Matrix[]}      [ broadcastedA, broadcastedB ]\n  */\n  return function (A, B) {\n    var N = Math.max(A._size.length, B._size.length); // max number of dims\n    if (A._size.length === B._size.length) {\n      if (A._size.every((dim, i) => dim === B._size[i])) {\n        // If matrices have the same size return them\n        return [A, B];\n      }\n    }\n    var sizeA = _padLeft(A._size, N, 0); // pad to the left to align dimensions to the right\n    var sizeB = _padLeft(B._size, N, 0); // pad to the left to align dimensions to the right\n\n    // calculate the max dimensions\n    var sizeMax = [];\n    for (var dim = 0; dim < N; dim++) {\n      sizeMax[dim] = Math.max(sizeA[dim], sizeB[dim]);\n    }\n\n    // check if the broadcasting rules applyes for both matrices\n    checkBroadcastingRules(sizeA, sizeMax);\n    checkBroadcastingRules(sizeB, sizeMax);\n\n    // reshape A or B if needed to make them ready for concat\n    var AA = A.clone();\n    var BB = B.clone();\n    if (AA._size.length < N) {\n      AA.reshape(_padLeft(AA._size, N, 1));\n    } else if (BB._size.length < N) {\n      BB.reshape(_padLeft(BB._size, N, 1));\n    }\n\n    // stretches the matrices on each dimension to make them the same size\n    for (var _dim = 0; _dim < N; _dim++) {\n      if (AA._size[_dim] < sizeMax[_dim]) {\n        AA = _stretch(AA, sizeMax[_dim], _dim);\n      }\n      if (BB._size[_dim] < sizeMax[_dim]) {\n        BB = _stretch(BB, sizeMax[_dim], _dim);\n      }\n    }\n\n    // return the array with the two broadcasted matrices\n    return [AA, BB];\n  };\n  function _padLeft(shape, N, filler) {\n    // pads an array of dimensions with numbers to the left, unitl the number of dimensions is N\n    return [...Array(N - shape.length).fill(filler), ...shape];\n  }\n  function _stretch(arrayToStretch, sizeToStretch, dimToStretch) {\n    // stretches a matrix up to a certain size in a certain dimension\n    return concat(...Array(sizeToStretch).fill(arrayToStretch), dimToStretch);\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}